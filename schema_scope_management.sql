-- ===============================================================================================
-- SCOPE MANAGEMENT - Role Profile Visibility Fix
-- This schema adds user_scope_assignments table and functions to track
-- which roles are "authorized" (created) vs "available for registration"
-- ===============================================================================================

-- -----------------------------------------------------------------------------------------------
-- DROP EXISTING OBJECTS (for clean re-run)
-- -----------------------------------------------------------------------------------------------

DROP TABLE IF EXISTS public.user_scope_assignments CASCADE;
DROP FUNCTION IF EXISTS public.get_user_authorized_scopes() CASCADE;
DROP FUNCTION IF EXISTS public.get_available_roles_for_registration() CASCADE;
DROP FUNCTION IF EXISTS public.activate_role_scope(text) CASCADE;
DROP FUNCTION IF EXISTS public.register_role_scope(text) CASCADE;

-- -----------------------------------------------------------------------------------------------
-- USER SCOPE ASSIGNMENTS TABLE
-- Tracks which roles each user has created/authorized vs available for registration
-- -----------------------------------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS public.user_scope_assignments (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    role_name text NOT NULL REFERENCES public.user_roles(name) ON DELETE CASCADE,
    status text NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'pending', 'registered')),
    scope_data jsonb DEFAULT '{}', -- Additional scope-specific data
    assigned_at timestamptz DEFAULT now(),
    activated_at timestamptz,
    created_by uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
    UNIQUE(user_id, role_name)
);

-- Index for fast lookups
CREATE INDEX IF NOT EXISTS idx_user_scope_assignments_user_id ON public.user_scope_assignments(user_id);
CREATE INDEX IF NOT EXISTS idx_user_scope_assignments_status ON public.user_scope_assignments(status);

-- -----------------------------------------------------------------------------------------------
-- RLS POLICIES FOR SCOPE ASSIGNMENTS
-- -----------------------------------------------------------------------------------------------

ALTER TABLE public.user_scope_assignments ENABLE ROW LEVEL SECURITY;

-- Users can view their own scope assignments
CREATE POLICY "Users can view their own scope assignments" ON public.user_scope_assignments
    FOR SELECT USING (user_id = auth.uid());

-- Users can insert their own scope assignments
CREATE POLICY "Users can manage their own scope assignments" ON public.user_scope_assignments
    FOR ALL USING (user_id = auth.uid());

-- -----------------------------------------------------------------------------------------------
-- FUNCTIONS FOR SCOPE MANAGEMENT
-- -----------------------------------------------------------------------------------------------

-- Get all authorized (active) scopes for the current user
CREATE OR REPLACE FUNCTION public.get_user_authorized_scopes()
RETURNS TABLE (
    id bigint,
    role_name text,
    display_name text,
    description text,
    status text,
    assigned_at timestamptz,
    activated_at timestamptz,
    permissions jsonb
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        usa.id,
        ur.name as role_name,
        ur.display_name,
        ur.description,
        usa.status,
        usa.assigned_at,
        usa.activated_at,
        COALESCE(ur.permissions, '{}'::jsonb) as permissions
    FROM public.user_scope_assignments usa
    JOIN public.user_roles ur ON usa.role_name = ur.name
    WHERE usa.user_id = auth.uid()
    AND usa.status = 'active'
    ORDER BY usa.activated_at DESC;
END;
$$;

-- Get all available roles that the user can register (not yet authorized)
CREATE OR REPLACE FUNCTION public.get_available_roles_for_registration()
RETURNS TABLE (
    name text,
    display_name text,
    description text,
    is_system_role boolean,
    permissions jsonb
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ur.name,
        ur.display_name,
        ur.description,
        ur.is_system_role,
        COALESCE(ur.permissions, '{}'::jsonb) as permissions
    FROM public.user_roles ur
    WHERE ur.name NOT IN (
        SELECT usa.role_name 
        FROM public.user_scope_assignments usa 
        WHERE usa.user_id = auth.uid()
        AND usa.status = 'active'
    )
    ORDER BY ur.name;
END;
$$;

-- Activate/register a new role scope for the current user
CREATE OR REPLACE FUNCTION public.register_role_scope(p_role_name text)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_result jsonb;
    v_role_exists boolean;
BEGIN
    -- Check if role exists
    SELECT EXISTS(SELECT 1 FROM public.user_roles WHERE name = p_role_name) INTO v_role_exists;
    IF NOT v_role_exists THEN
        RETURN jsonb_build_object(
            'success', false,
            'message', 'Role does not exist: ' || p_role_name
        );
    END IF;

    -- Check if user already has this scope active
    IF EXISTS (
        SELECT 1 FROM public.user_scope_assignments 
        WHERE user_id = auth.uid() 
        AND role_name = p_role_name 
        AND status = 'active'
    ) THEN
        RETURN jsonb_build_object(
            'success', false,
            'message', 'You already have this scope active'
        );
    END IF;

    -- Check if there's a pending registration
    IF EXISTS (
        SELECT 1 FROM public.user_scope_assignments 
        WHERE user_id = auth.uid() 
        AND role_name = p_role_name 
        AND status IN ('pending', 'registered')
    ) THEN
        -- Update existing pending record to active
        UPDATE public.user_scope_assignments
        SET status = 'active', activated_at = now()
        WHERE user_id = auth.uid() AND role_name = p_role_name;
    ELSE
        -- Create new scope assignment
        INSERT INTO public.user_scope_assignments (user_id, role_name, status, activated_at)
        VALUES (auth.uid(), p_role_name, 'active', now());
    END IF;

    -- Return the activated scope
    SELECT json_build_object(
        'success', true,
        'scope', json_build_object(
            'role_name', p_role_name,
            'activated_at', now()::text
        )
    ) INTO v_result;

    RETURN v_result;
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'success', false,
        'message', SQLERRM
    );
END;
$$;

-- Deactivate a role scope (soft delete)
CREATE OR REPLACE FUNCTION public.deactivate_role_scope(p_role_name text)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    UPDATE public.user_scope_assignments
    SET status = 'inactive'
    WHERE user_id = auth.uid() AND role_name = p_role_name AND status = 'active';

    IF FOUND THEN
        RETURN jsonb_build_object('success', true, 'message', 'Scope deactivated');
    ELSE
        RETURN jsonb_build_object('success', false, 'message', 'Scope not found or already inactive');
    END IF;
END;
$$;

-- Get all scopes for a user (both active and inactive)
CREATE OR REPLACE FUNCTION public.get_all_user_scopes()
RETURNS TABLE (
    id bigint,
    role_name text,
    display_name text,
    status text,
    is_active boolean,
    assigned_at timestamptz,
    activated_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        usa.id,
        ur.name as role_name,
        ur.display_name,
        usa.status,
        CASE WHEN usa.status = 'active' THEN true ELSE false END as is_active,
        usa.assigned_at,
        usa.activated_at
    FROM public.user_scope_assignments usa
    JOIN public.user_roles ur ON usa.role_name = ur.name
    WHERE usa.user_id = auth.uid()
    ORDER BY usa.activated_at DESC NULLS LAST;
END;
$$;

-- Seed existing user_role_assignments into user_scope_assignments (run once)
CREATE OR REPLACE FUNCTION public.migrate_existing_role_assignments()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    rec record;
BEGIN
    -- For each user with role assignments, create scope entries
    FOR rec IN 
        SELECT DISTINCT user_id, role_name FROM public.user_role_assignments
        WHERE user_id IS NOT NULL
    LOOP
        INSERT INTO public.user_scope_assignments (user_id, role_name, status, activated_at)
        VALUES (rec.user_id, rec.role_name, 'active', now())
        ON CONFLICT (user_id, role_name) DO NOTHING;
    END LOOP;
END;
$$;

SELECT 'Scope management functions created successfully!' as result;
