-- ===============================================================================================
-- GURUKUL OS â€” Enterprise School Management Architecture (v12.0.0)
-- ===============================================================================================

-- SAFE DROP BLOCK
DO $$ DECLARE r RECORD;
BEGIN
  FOR r IN (
    SELECT schemaname, tablename, policyname
    FROM pg_policies
    WHERE schemaname IN ('public', 'storage')
  ) LOOP
    EXECUTE format(
      'DROP POLICY IF EXISTS %I ON %I.%I',
      r.policyname, r.schemaname, r.tablename
    );
  END LOOP;
END $$;

DO $$ DECLARE r RECORD;
BEGIN
  FOR r IN (
    SELECT tablename FROM pg_tables WHERE schemaname = 'public'
  ) LOOP
    EXECUTE format(
      'ALTER TABLE public.%I DISABLE ROW LEVEL SECURITY',
      r.tablename
    );
  END LOOP;
END $$;

DO $$ DECLARE func_record RECORD;
BEGIN
  -- Drop functions only if profiles table exists
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'profiles') THEN
    FOR func_record IN (
      SELECT
        n.nspname as schema_name,
        p.proname as function_name,
        pg_get_function_identity_arguments(p.oid) as arg_types
      FROM pg_proc p
      JOIN pg_namespace n ON n.oid = p.pronamespace
      WHERE n.nspname = 'public'
    ) LOOP
      EXECUTE format(
        'DROP FUNCTION IF EXISTS %I.%I(%s) CASCADE',
        func_record.schema_name,
        func_record.function_name,
        func_record.arg_types
      );
    END LOOP;
  END IF;
END $$;

DROP TABLE IF EXISTS
  payment_transactions,
  order_items,
  orders,
  products,
  transport_attendance,
  student_transport_assignments,
  transport_vehicles,
  transport_routes,
  communications,
  expenses,
  fee_payments,
  fee_invoices,
  student_fee_assignments,
  fee_components,
  fee_structures,
  admission_documents,
  document_requirements,
  admissions,
  enquiry_messages,
  enquiries,
  share_codes,
  exam_results,
  exams,
  assignment_submissions,
  assignments,
  attendance_records,
  lesson_plans,
  class_timetables,
  teacher_subject_assignments,
  class_subjects,
  courses,
  school_classes,
  academic_years,
  school_departments,
  branch_access_keys,
  school_branches,
  user_roles,
  profiles
CASCADE;

DROP TYPE IF EXISTS user_role_enum CASCADE;
DROP EXTENSION IF EXISTS "uuid-ossp";

-- FULL SCHEMA RE-CREATION

-- Extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Enums
CREATE TYPE user_role_enum AS ENUM (
  'super_admin',
  'school_admin',
  'teacher',
  'student',
  'parent',
  'transport_staff',
  'ecommerce_operator',
  'minimal_admin'
);

-- Helper functions
CREATE OR REPLACE FUNCTION public.has_role(role TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid()
    AND profiles.role = has_role.role
  );
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.is_super_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN public.has_role('super_admin');
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.is_school_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN public.has_role('school_admin');
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.current_branch_id()
RETURNS UUID AS $$
BEGIN
  RETURN (
    SELECT branch_id FROM public.profiles
    WHERE id = auth.uid()
  );
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.is_branch_member(branch UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN public.current_branch_id() = branch OR public.is_super_admin();
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.is_teacher_of_class(class UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.teacher_subject_assignments tsa
    WHERE tsa.teacher_id = auth.uid()
    AND tsa.class_id = class
    AND tsa.status = 'Active'
  ) OR public.is_school_admin();
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.is_parent_of_student(student UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.admissions a
    WHERE a.parent_id = auth.uid()
    AND a.student_user_id = student
  );
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.is_student_self(student UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN auth.uid() = student AND public.has_role('student');
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Core identity tables
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  email TEXT UNIQUE NOT NULL,
  display_name TEXT,
  phone TEXT,
  role user_role_enum,
  profile_completed BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,
  email_confirmed_at TIMESTAMPTZ,
  profile_photo_url TEXT,
  address TEXT,
  city TEXT,
  state TEXT,
  country TEXT,
  pin_code TEXT,
  date_of_birth DATE,
  gender TEXT,
  emergency_contact TEXT,
  updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE public.user_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  role user_role_enum NOT NULL,
  assigned_at TIMESTAMPTZ DEFAULT now(),
  assigned_by UUID REFERENCES auth.users(id)
);

CREATE TABLE public.school_branches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  name TEXT NOT NULL,
  address TEXT,
  city TEXT,
  state TEXT,
  country TEXT,
  is_main_branch BOOLEAN DEFAULT false,
  admin_name TEXT,
  admin_phone TEXT,
  admin_email TEXT,
  status TEXT DEFAULT 'Active' CHECK (status IN ('Active', 'Inactive', 'Linked', 'Pending')),
  academic_year_start DATE,
  academic_year_end DATE,
  grade_range_start TEXT,
  grade_range_end TEXT,
  contact_person_name TEXT,
  contact_person_phone TEXT,
  contact_person_email TEXT,
  established_date DATE
);

CREATE TABLE public.school_departments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  name TEXT NOT NULL,
  description TEXT,
  hod_id UUID REFERENCES public.profiles(id),
  teacher_count INT DEFAULT 0,
  course_count INT DEFAULT 0,
  is_active BOOLEAN DEFAULT true
);

CREATE TABLE public.academic_years (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  year_name TEXT NOT NULL,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  is_current BOOLEAN DEFAULT false,
  status TEXT DEFAULT 'Active' CHECK (status IN ('Active', 'Inactive', 'Completed'))
);

CREATE TABLE public.branch_access_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  access_key TEXT UNIQUE NOT NULL,
  expires_at TIMESTAMPTZ,
  is_active BOOLEAN DEFAULT true,
  granted_by UUID REFERENCES auth.users(id)
);

CREATE TABLE public.school_plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  plan_name TEXT NOT NULL,
  features JSONB,
  max_users INT,
  max_branches INT,
  price DECIMAL(10,2),
  billing_cycle TEXT CHECK (billing_cycle IN ('monthly', 'yearly')),
  status TEXT DEFAULT 'Active' CHECK (status IN ('Active', 'Inactive', 'Cancelled'))
);

-- Academic modules
CREATE TABLE public.school_classes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  name TEXT NOT NULL,
  grade_level TEXT NOT NULL,
  section TEXT,
  academic_year TEXT,
  class_teacher_id UUID REFERENCES public.profiles(id),
  department_id UUID REFERENCES public.school_departments(id),
  capacity INT DEFAULT 30,
  student_count INT DEFAULT 0,
  description TEXT,
  room_number TEXT,
  is_active BOOLEAN DEFAULT true
);

CREATE TABLE public.courses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  title TEXT NOT NULL,
  code TEXT UNIQUE,
  grade_level TEXT,
  description TEXT,
  credits INT DEFAULT 1,
  category TEXT,
  subject_type TEXT DEFAULT 'Academic' CHECK (subject_type IN ('Academic', 'Elective', 'Co-curricular', 'Sports', 'Arts')),
  status TEXT DEFAULT 'Active' CHECK (status IN ('Active', 'Draft', 'Archived', 'Pending', 'Inactive')),
  syllabus TEXT,
  objectives TEXT
);

CREATE TABLE public.class_subjects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  class_id UUID REFERENCES public.school_classes(id) ON DELETE CASCADE,
  course_id UUID REFERENCES public.courses(id) ON DELETE CASCADE,
  teacher_id UUID REFERENCES public.profiles(id),
  academic_year TEXT,
  is_active BOOLEAN DEFAULT true
);

CREATE TABLE public.teacher_subject_assignments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  teacher_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  course_id UUID REFERENCES public.courses(id) ON DELETE CASCADE,
  class_id UUID REFERENCES public.school_classes(id) ON DELETE CASCADE,
  academic_year TEXT,
  workload_hours INT DEFAULT 1,
  is_primary BOOLEAN DEFAULT false,
  status TEXT DEFAULT 'Active' CHECK (status IN ('Active', 'Inactive', 'Pending'))
);

CREATE TABLE public.class_timetables (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  class_id UUID REFERENCES public.school_classes(id) ON DELETE CASCADE,
  day_of_week TEXT CHECK (day_of_week IN ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')),
  start_time TIME NOT NULL,
  end_time TIME NOT NULL,
  course_id UUID REFERENCES public.courses(id),
  teacher_id UUID REFERENCES public.profiles(id),
  room_number TEXT,
  subject_name TEXT,
  is_active BOOLEAN DEFAULT true
);

CREATE TABLE public.lesson_plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  class_id UUID REFERENCES public.school_classes(id) ON DELETE CASCADE,
  course_id UUID REFERENCES public.courses(id) ON DELETE CASCADE,
  teacher_id UUID REFERENCES public.profiles(id),
  title TEXT NOT NULL,
  objectives TEXT,
  activities TEXT,
  resources TEXT[],
  lesson_date DATE,
  duration_minutes INT,
  status TEXT DEFAULT 'Draft' CHECK (status IN ('Draft', 'Published', 'Completed'))
);

-- Attendance
CREATE TABLE public.attendance_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  student_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  class_id UUID REFERENCES public.school_classes(id) ON DELETE CASCADE,
  attendance_date DATE NOT NULL,
  status TEXT DEFAULT 'Present' CHECK (status IN ('Present', 'Absent', 'Late', 'Excused')),
  notes TEXT,
  marked_by UUID REFERENCES public.profiles(id),
  UNIQUE(student_id, class_id, attendance_date)
);

-- Assignments & Exams
CREATE TABLE public.assignments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  course_id UUID REFERENCES public.courses(id) ON DELETE CASCADE,
  class_id UUID REFERENCES public.school_classes(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  instructions TEXT,
  assignment_type TEXT DEFAULT 'Homework' CHECK (assignment_type IN ('Homework', 'Project', 'Quiz', 'Exam', 'Lab')),
  due_date TIMESTAMPTZ,
  total_marks INT DEFAULT 100,
  attachments TEXT[],
  status TEXT DEFAULT 'Active' CHECK (status IN ('Active', 'Draft', 'Published', 'Closed'))
);

CREATE TABLE public.assignment_submissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  assignment_id UUID REFERENCES public.assignments(id) ON DELETE CASCADE,
  student_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  submission_text TEXT,
  file_paths TEXT[],
  submitted_at TIMESTAMPTZ DEFAULT now(),
  is_late BOOLEAN DEFAULT false,
  status TEXT DEFAULT 'Not Submitted' CHECK (status IN ('Not Submitted', 'Submitted', 'Late', 'Graded')),
  marks_obtained INT,
  teacher_feedback TEXT,
  graded_by UUID REFERENCES public.profiles(id),
  graded_at TIMESTAMPTZ,
  UNIQUE(assignment_id, student_id)
);

CREATE TABLE public.exams (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  course_id UUID REFERENCES public.courses(id) ON DELETE CASCADE,
  class_id UUID REFERENCES public.school_classes(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  exam_type TEXT CHECK (exam_type IN ('Midterm', 'Final', 'Quiz', 'Test', 'Practical', 'Assignment')),
  exam_date TIMESTAMPTZ NOT NULL,
  duration_minutes INT,
  total_marks INT DEFAULT 100,
  instructions TEXT,
  room_number TEXT,
  status TEXT DEFAULT 'Scheduled' CHECK (status IN ('Scheduled', 'In Progress', 'Completed', 'Cancelled'))
);

CREATE TABLE public.exam_results (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  exam_id UUID REFERENCES public.exams(id) ON DELETE CASCADE,
  student_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  marks_obtained INT,
  grade TEXT,
  rank INT,
  status TEXT DEFAULT 'Pending' CHECK (status IN ('Pending', 'Published', 'Corrected')),
  remarks TEXT,
  graded_by UUID REFERENCES public.profiles(id),
  graded_at TIMESTAMPTZ,
  UNIQUE(exam_id, student_id)
);

-- Admissions
CREATE TABLE public.enquiries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  applicant_name TEXT NOT NULL,
  parent_name TEXT,
  parent_email TEXT,
  parent_phone TEXT,
  grade TEXT NOT NULL,
  status TEXT DEFAULT 'New' CHECK (status IN ('New', 'Contacted', 'Verified', 'In Review', 'Completed', 'Rejected')),
  notes TEXT,
  received_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE public.enquiry_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  enquiry_id UUID REFERENCES public.enquiries(id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  is_from_admin BOOLEAN DEFAULT false,
  sent_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE public.admissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  applicant_name TEXT NOT NULL,
  grade TEXT NOT NULL,
  status TEXT DEFAULT 'Pending Review' CHECK (status IN ('Pending Review', 'Documents Requested', 'Approved', 'Rejected', 'Waitlisted')),
  submitted_at TIMESTAMPTZ DEFAULT now(),
  parent_id UUID REFERENCES public.profiles(id),
  parent_name TEXT,
  parent_email TEXT,
  parent_phone TEXT,
  date_of_birth DATE,
  gender TEXT,
  profile_photo_url TEXT,
  medical_info TEXT,
  emergency_contact TEXT,
  application_number TEXT UNIQUE,
  student_user_id UUID REFERENCES public.profiles(id),
  previous_school TEXT,
  previous_grade TEXT,
  transport_required BOOLEAN DEFAULT false,
  special_requirements TEXT,
  notes TEXT,
  reviewed_by UUID REFERENCES public.profiles(id),
  reviewed_at TIMESTAMPTZ
);

CREATE TABLE public.document_requirements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  admission_id UUID REFERENCES public.admissions(id) ON DELETE CASCADE,
  document_name TEXT NOT NULL,
  status TEXT DEFAULT 'Pending' CHECK (status IN ('Pending', 'Submitted', 'Accepted', 'Rejected', 'Verified')),
  notes_for_parent TEXT,
  rejection_reason TEXT,
  is_mandatory BOOLEAN DEFAULT true,
  document_type TEXT
);

CREATE TABLE public.admission_documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  requirement_id UUID REFERENCES public.document_requirements(id) ON DELETE CASCADE,
  admission_id UUID REFERENCES public.admissions(id) ON DELETE CASCADE,
  file_name TEXT NOT NULL,
  storage_path TEXT NOT NULL,
  file_size BIGINT,
  mime_type TEXT,
  uploaded_at TIMESTAMPTZ DEFAULT now(),
  verified_by UUID REFERENCES public.profiles(id),
  verified_at TIMESTAMPTZ
);

CREATE TABLE public.share_codes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  code TEXT UNIQUE NOT NULL,
  admission_id UUID REFERENCES public.admissions(id) ON DELETE CASCADE,
  applicant_name TEXT,
  status TEXT DEFAULT 'Active' CHECK (status IN ('Active', 'Expired', 'Revoked', 'Redeemed')),
  code_type TEXT DEFAULT 'Admission' CHECK (code_type IN ('Enquiry', 'Admission')),
  expires_at TIMESTAMPTZ,
  redeemed_at TIMESTAMPTZ,
  redeemed_by UUID REFERENCES auth.users(id)
);

-- Finance
CREATE TABLE public.fee_structures (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  academic_year TEXT NOT NULL,
  name TEXT NOT NULL,
  target_grade TEXT,
  description TEXT,
  currency TEXT DEFAULT 'INR',
  total_amount DECIMAL(12,2),
  status TEXT DEFAULT 'Active' CHECK (status IN ('Active', 'Inactive', 'Draft')),
  effective_from DATE,
  effective_to DATE
);

CREATE TABLE public.fee_components (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  fee_structure_id UUID REFERENCES public.fee_structures(id) ON DELETE CASCADE,
  component_name TEXT NOT NULL,
  amount DECIMAL(12,2) NOT NULL,
  is_mandatory BOOLEAN DEFAULT true,
  due_date DATE,
  late_fee DECIMAL(8,2) DEFAULT 0,
  description TEXT
);

CREATE TABLE public.student_fee_assignments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  student_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  fee_structure_id UUID REFERENCES public.fee_structures(id) ON DELETE CASCADE,
  assigned_date DATE DEFAULT CURRENT_DATE,
  status TEXT DEFAULT 'Active' CHECK (status IN ('Active', 'Inactive', 'Waived')),
  discount_percentage DECIMAL(5,2) DEFAULT 0,
  discount_amount DECIMAL(10,2) DEFAULT 0,
  assigned_by UUID REFERENCES public.profiles(id)
);

CREATE TABLE public.fee_invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  student_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  fee_structure_id UUID REFERENCES public.fee_structures(id) ON DELETE CASCADE,
  invoice_number TEXT UNIQUE NOT NULL,
  due_date DATE NOT NULL,
  total_amount DECIMAL(12,2) NOT NULL,
  paid_amount DECIMAL(12,2) DEFAULT 0,
  status TEXT DEFAULT 'Pending' CHECK (status IN ('Pending', 'Partial', 'Paid', 'Overdue', 'Cancelled')),
  payment_method TEXT,
  academic_year TEXT,
  description TEXT
);

CREATE TABLE public.fee_payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  invoice_id UUID REFERENCES public.fee_invoices(id) ON DELETE CASCADE,
  amount DECIMAL(12,2) NOT NULL,
  payment_date TIMESTAMPTZ DEFAULT now(),
  payment_method TEXT CHECK (payment_method IN ('Cash', 'Cheque', 'Online', 'Bank Transfer', 'Card')),
  transaction_id TEXT,
  receipt_number TEXT,
  collected_by UUID REFERENCES public.profiles(id),
  notes TEXT
);

CREATE TABLE public.expenses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  expense_date DATE NOT NULL,
  category TEXT NOT NULL,
  subcategory TEXT,
  amount DECIMAL(12,2) NOT NULL,
  vendor_name TEXT,
  description TEXT,
  receipt_url TEXT,
  status TEXT DEFAULT 'Pending' CHECK (status IN ('Pending', 'Approved', 'Rejected', 'Paid')),
  approved_by UUID REFERENCES public.profiles(id),
  approved_at TIMESTAMPTZ
);

-- Communication
CREATE TABLE public.communications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  subject TEXT NOT NULL,
  body TEXT NOT NULL,
  sent_at TIMESTAMPTZ DEFAULT now(),
  sender_id UUID REFERENCES public.profiles(id),
  status TEXT DEFAULT 'Sent' CHECK (status IN ('Draft', 'Sent', 'Failed')),
  recipients JSONB,
  target_criteria JSONB,
  attachment_urls TEXT[]
);

-- Transport
CREATE TABLE public.transport_routes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  route_name TEXT NOT NULL,
  description TEXT,
  start_location TEXT,
  end_location TEXT,
  estimated_duration_minutes INT,
  fare DECIMAL(8,2),
  capacity INT,
  status TEXT DEFAULT 'Active' CHECK (status IN ('Active', 'Inactive', 'Maintenance'))
);

CREATE TABLE public.transport_vehicles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  route_id UUID REFERENCES public.transport_routes(id),
  vehicle_number TEXT UNIQUE NOT NULL,
  vehicle_type TEXT,
  capacity INT,
  driver_id UUID REFERENCES public.profiles(id),
  conductor_id UUID REFERENCES public.profiles(id),
  fuel_type TEXT,
  purchase_date DATE,
  insurance_expiry DATE,
  fitness_expiry DATE,
  status TEXT DEFAULT 'Active' CHECK (status IN ('Active', 'Inactive', 'Maintenance', 'Retired'))
);

CREATE TABLE public.student_transport_assignments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  student_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  route_id UUID REFERENCES public.transport_routes(id) ON DELETE CASCADE,
  pickup_location TEXT,
  drop_location TEXT,
  is_active BOOLEAN DEFAULT true,
  assigned_date DATE DEFAULT CURRENT_DATE,
  assigned_by UUID REFERENCES public.profiles(id)
);

CREATE TABLE public.transport_attendance (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  student_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  route_id UUID REFERENCES public.transport_routes(id) ON DELETE CASCADE,
  trip_date DATE NOT NULL,
  trip_type TEXT CHECK (trip_type IN ('Pickup', 'Drop')),
  status TEXT DEFAULT 'Present' CHECK (status IN ('Present', 'Absent', 'Late')),
  notes TEXT,
  marked_by UUID REFERENCES public.profiles(id),
  UNIQUE(student_id, route_id, trip_date, trip_type)
);

-- E-commerce
CREATE TABLE public.products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  name TEXT NOT NULL,
  description TEXT,
  price DECIMAL(10,2) NOT NULL,
  category TEXT,
  stock_quantity INT DEFAULT 0,
  image_url TEXT,
  is_active BOOLEAN DEFAULT true,
  sku TEXT UNIQUE
);

CREATE TABLE public.orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  customer_id UUID REFERENCES public.profiles(id),
  order_number TEXT UNIQUE NOT NULL,
  total_amount DECIMAL(12,2) NOT NULL,
  status TEXT DEFAULT 'Pending' CHECK (status IN ('Pending', 'Confirmed', 'Processing', 'Shipped', 'Delivered', 'Cancelled')),
  shipping_address TEXT,
  payment_status TEXT DEFAULT 'Pending' CHECK (payment_status IN ('Pending', 'Paid', 'Failed', 'Refunded')),
  ordered_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE public.order_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  order_id UUID REFERENCES public.orders(id) ON DELETE CASCADE,
  product_id UUID REFERENCES public.products(id),
  quantity INT NOT NULL,
  unit_price DECIMAL(10,2) NOT NULL,
  total_price DECIMAL(10,2) NOT NULL
);

CREATE TABLE public.payment_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  branch_id UUID NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  order_id UUID REFERENCES public.orders(id) ON DELETE CASCADE,
  amount DECIMAL(12,2) NOT NULL,
  payment_method TEXT CHECK (payment_method IN ('Cash', 'Card', 'Online', 'Bank Transfer')),
  transaction_id TEXT UNIQUE,
  status TEXT DEFAULT 'Pending' CHECK (status IN ('Pending', 'Completed', 'Failed', 'Refunded')),
  processed_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_profiles_email ON public.profiles(email);
CREATE INDEX idx_profiles_role ON public.profiles(role);
CREATE INDEX idx_profiles_branch_id ON public.profiles(branch_id);
CREATE INDEX idx_school_branches_status ON public.school_branches(status);
CREATE INDEX idx_school_classes_branch_id ON public.school_classes(branch_id);
CREATE INDEX idx_courses_branch_id ON public.courses(branch_id);
CREATE INDEX idx_attendance_records_student_id ON public.attendance_records(student_id);
CREATE INDEX idx_attendance_records_date ON public.attendance_records(attendance_date);
CREATE INDEX idx_assignments_class_id ON public.assignments(class_id);
CREATE INDEX idx_exams_class_id ON public.exams(class_id);
CREATE INDEX idx_admissions_status ON public.admissions(status);
CREATE INDEX idx_fee_invoices_student_id ON public.fee_invoices(student_id);
CREATE INDEX idx_fee_payments_invoice_id ON public.fee_payments(invoice_id);
CREATE INDEX idx_transport_attendance_student_id ON public.transport_attendance(student_id);

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.school_branches ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.school_departments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.academic_years ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.branch_access_keys ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.school_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.school_classes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.courses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.class_subjects ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.teacher_subject_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.class_timetables ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.lesson_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.attendance_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.assignment_submissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.exams ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.exam_results ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.enquiries ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.enquiry_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.document_requirements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admission_documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.share_codes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fee_structures ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fee_components ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.student_fee_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fee_invoices ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fee_payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.expenses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.communications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transport_routes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transport_vehicles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.student_transport_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transport_attendance ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;

-- RLS policies
-- Profiles
CREATE POLICY "Super admin can view all profiles" ON public.profiles
  FOR SELECT USING (public.is_super_admin());

CREATE POLICY "Users can view their own profile" ON public.profiles
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Branch members can view profiles in their branch" ON public.profiles
  FOR SELECT USING (public.is_branch_member(branch_id));

CREATE POLICY "Users can insert their own profile" ON public.profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

CREATE POLICY "Super admin can insert profiles" ON public.profiles
  FOR INSERT WITH CHECK (public.is_super_admin());

CREATE POLICY "Users can update their own profile" ON public.profiles
  FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "School admins can update profiles in their branch" ON public.profiles
  FOR UPDATE USING (public.is_school_admin() AND public.is_branch_member(branch_id));

-- School branches
CREATE POLICY "Super admin can manage all branches" ON public.school_branches
  FOR ALL USING (public.is_super_admin());

CREATE POLICY "Branch members can view their branch" ON public.school_branches
  FOR SELECT USING (public.is_branch_member(id));

-- School classes
CREATE POLICY "Branch members can view classes in their branch" ON public.school_classes
  FOR SELECT USING (public.is_branch_member(branch_id));

CREATE POLICY "Teachers can view their classes" ON public.school_classes
  FOR SELECT USING (public.is_teacher_of_class(id));

CREATE POLICY "School admins can manage classes in their branch" ON public.school_classes
  FOR ALL USING (public.is_school_admin() AND public.is_branch_member(branch_id));

-- Attendance records
CREATE POLICY "Teachers can view attendance for their classes" ON public.attendance_records
  FOR SELECT USING (public.is_teacher_of_class(class_id));

CREATE POLICY "Students can view their own attendance" ON public.attendance_records
  FOR SELECT USING (public.is_student_self(student_id));

CREATE POLICY "Parents can view their children's attendance" ON public.attendance_records
  FOR SELECT USING (public.is_parent_of_student(student_id));

CREATE POLICY "School admins can manage attendance in their branch" ON public.attendance_records
  FOR ALL USING (public.is_school_admin() AND public.is_branch_member(branch_id));

-- Assignments
CREATE POLICY "Teachers can manage assignments for their classes" ON public.assignments
  FOR ALL USING (public.is_teacher_of_class(class_id) OR (public.is_school_admin() AND public.is_branch_member(branch_id)));

CREATE POLICY "Students can view assignments in their branch" ON public.assignments
  FOR SELECT USING (public.has_role('student') AND public.is_branch_member(branch_id));

-- Assignment submissions
CREATE POLICY "Students can manage their own submissions" ON public.assignment_submissions
  FOR ALL USING (public.is_student_self(student_id));

CREATE POLICY "Teachers can view and grade submissions for their assignments" ON public.assignment_submissions
  FOR ALL USING (EXISTS (SELECT 1 FROM public.assignments a WHERE a.id = assignment_id AND public.is_teacher_of_class(a.class_id)));

-- Admissions
CREATE POLICY "Super admin can view all admissions" ON public.admissions
  FOR SELECT USING (public.is_super_admin());

CREATE POLICY "School admins can manage admissions in their branch" ON public.admissions
  FOR ALL USING (public.is_school_admin() AND public.is_branch_member(branch_id));

CREATE POLICY "Parents can view their own admissions" ON public.admissions
  FOR SELECT USING (auth.uid() = parent_id);

-- Fee invoices
CREATE POLICY "Students can view their own invoices" ON public.fee_invoices
  FOR SELECT USING (public.is_student_self(student_id));

CREATE POLICY "Parents can view their children's invoices" ON public.fee_invoices
  FOR SELECT USING (public.is_parent_of_student(student_id));

CREATE POLICY "School admins can manage invoices in their branch" ON public.fee_invoices
  FOR ALL USING (public.is_school_admin() AND public.is_branch_member(branch_id));

-- Transport attendance
CREATE POLICY "Transport staff can manage transport attendance" ON public.transport_attendance
  FOR ALL USING (public.has_role('transport_staff') AND public.is_branch_member(branch_id));

CREATE POLICY "Students and parents can view relevant transport attendance" ON public.transport_attendance
  FOR SELECT USING (public.is_student_self(student_id) OR public.is_parent_of_student(student_id));

-- Products
CREATE POLICY "Ecommerce operators can manage products" ON public.products
  FOR ALL USING (public.has_role('ecommerce_operator') AND public.is_branch_member(branch_id));

CREATE POLICY "All users can view active products" ON public.products
  FOR SELECT USING (is_active = true);

-- Orders
CREATE POLICY "Users can view their own orders" ON public.orders
  FOR SELECT USING (auth.uid() = customer_id);

CREATE POLICY "Ecommerce operators can manage orders" ON public.orders
  FOR ALL USING (public.has_role('ecommerce_operator') AND public.is_branch_member(branch_id));

-- RPCs
CREATE OR REPLACE FUNCTION public.switch_active_role(new_role user_role_enum)
RETURNS BOOLEAN AS $$
DECLARE
  user_id UUID := auth.uid();
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = user_id AND role = new_role) THEN
    RETURN false;
  END IF;
  
  UPDATE public.profiles SET role = new_role WHERE id = user_id;
  RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.initialize_school_admin(branch_id UUID, admin_data JSONB)
RETURNS UUID AS $$
DECLARE
  new_user_id UUID;
BEGIN
  IF NOT public.is_super_admin() THEN
    RAISE EXCEPTION 'Only super admin can initialize school admin';
  END IF;
  
  INSERT INTO public.profiles (branch_id, email, display_name, role, profile_completed)
  VALUES (branch_id, admin_data->>'email', admin_data->>'name', 'school_admin', true)
  RETURNING id INTO new_user_id;
  
  INSERT INTO public.user_roles (user_id, role, branch_id)
  VALUES (new_user_id, 'school_admin', branch_id);
  
  RETURN new_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.complete_school_onboarding(branch_id UUID, onboarding_data JSONB)
RETURNS BOOLEAN AS $$
BEGIN
  IF NOT public.is_school_admin() THEN
    RAISE EXCEPTION 'Only school admin can complete onboarding';
  END IF;
  
  UPDATE public.school_branches SET
    name = onboarding_data->>'school_name',
    address = onboarding_data->>'address',
    status = 'Active'
  WHERE id = branch_id;
  
  RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.get_teacher_classes(teacher_id UUID DEFAULT auth.uid())
RETURNS TABLE (
  class_id UUID,
  class_name TEXT,
  subject_name TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    sc.id,
    sc.name,
    c.title
  FROM public.teacher_subject_assignments tsa
  JOIN public.school_classes sc ON sc.id = tsa.class_id
  JOIN public.courses c ON c.id = tsa.course_id
  WHERE tsa.teacher_id = teacher_id
  AND tsa.status = 'Active'
  AND sc.is_active = true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.upsert_attendance(attendance_data JSONB)
RETURNS BOOLEAN AS $$
DECLARE
  record_data JSONB;
  student_id UUID;
  class_id UUID;
  attendance_date DATE;
  status TEXT;
BEGIN
  IF NOT (public.is_school_admin() OR public.is_teacher_of_class((attendance_data->>'class_id')::UUID)) THEN
    RAISE EXCEPTION 'Insufficient permissions';
  END IF;
  
  FOR record_data IN SELECT * FROM jsonb_array_elements(attendance_data->'records')
  LOOP
    student_id := (record_data->>'student_id')::UUID;
    class_id := (attendance_data->>'class_id')::UUID;
    attendance_date := (record_data->>'date')::DATE;
    status := record_data->>'status';
    
    INSERT INTO public.attendance_records (student_id, class_id, attendance_date, status, marked_by, branch_id)
    VALUES (student_id, class_id, attendance_date, status, auth.uid(), public.current_branch_id())
    ON CONFLICT (student_id, class_id, attendance_date)
    DO UPDATE SET
      status = EXCLUDED.status,
      marked_by = EXCLUDED.marked_by;
  END LOOP;
  
  RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.generate_admission_share_code(admission_id UUID)
RETURNS TEXT AS $$
DECLARE
  code TEXT;
  applicant_name TEXT;
BEGIN
  IF NOT public.is_school_admin() THEN
    RAISE EXCEPTION 'Only school admin can generate share codes';
  END IF;
  
  SELECT applicant_name INTO applicant_name FROM public.admissions WHERE id = admission_id;
  
  code := encode(gen_random_bytes(6), 'base64');
  code := regexp_replace(code, '[^a-zA-Z0-9]', '', 'g');
  code := substring(code, 1, 8);
  
  INSERT INTO public.share_codes (code, admission_id, applicant_name, expires_at, branch_id)
  VALUES (code, admission_id, applicant_name, now() + interval '7 days', public.current_branch_id());
  
  RETURN code;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.admin_verify_share_code(code TEXT)
RETURNS JSONB AS $$
DECLARE
  result JSONB;
BEGIN
  IF NOT public.is_school_admin() THEN
    RAISE EXCEPTION 'Only school admin can verify codes';
  END IF;
  
  SELECT jsonb_build_object(
    'found', true,
    'admission_id', admission_id,
    'applicant_name', applicant_name,
    'code_type', code_type
  ) INTO result
  FROM public.share_codes
  WHERE share_codes.code = admin_verify_share_code.code
  AND status = 'Active'
  AND expires_at > now();
  
  IF result IS NULL THEN
    result := jsonb_build_object('found', false);
  END IF;
  
  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.publish_fee_structure(fee_structure_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  IF NOT public.is_school_admin() THEN
    RAISE EXCEPTION 'Only school admin can publish fee structures';
  END IF;
  
  UPDATE public.fee_structures SET status = 'Active' WHERE id = fee_structure_id;
  RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.upsert_bus_attendance(attendance_data JSONB)
RETURNS BOOLEAN AS $$
DECLARE
  record_data JSONB;
  student_id UUID;
  route_id UUID;
  trip_date DATE;
  trip_type TEXT;
  status TEXT;
BEGIN
  IF NOT public.has_role('transport_staff') THEN
    RAISE EXCEPTION 'Only transport staff can manage bus attendance';
  END IF;
  
  FOR record_data IN SELECT * FROM jsonb_array_elements(attendance_data->'records')
  LOOP
    student_id := (record_data->>'student_id')::UUID;
    route_id := (record_data->>'route_id')::UUID;
    trip_date := (record_data->>'date')::DATE;
    trip_type := record_data->>'trip_type';
    status := record_data->>'status';
    
    INSERT INTO public.transport_attendance (student_id, route_id, trip_date, trip_type, status, marked_by, branch_id)
    VALUES (student_id, route_id, trip_date, trip_type, status, auth.uid(), public.current_branch_id())
    ON CONFLICT (student_id, route_id, trip_date, trip_type)
    DO UPDATE SET
      status = EXCLUDED.status,
      marked_by = EXCLUDED.marked_by;
  END LOOP;
  
  RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Storage buckets
INSERT INTO storage.buckets (id, name, public)
VALUES
  ('profile-images', 'profile-images', true),
  ('guardian-documents', 'guardian-documents', false)
ON CONFLICT (id) DO NOTHING;

-- Storage policies
CREATE POLICY "Users can upload their own profile images" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'profile-images' 
    AND auth.uid()::text = (storage.foldername(name))[1]
  );

CREATE POLICY "Anyone can view profile images" ON storage.objects
  FOR SELECT USING (bucket_id = 'profile-images');

CREATE POLICY "Parents can upload guardian documents" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'guardian-documents'
    AND EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() 
      AND role = 'parent'
      AND auth.uid()::text = (storage.foldername(name))[1]
    )
  );

CREATE POLICY "Parents can view their own guardian documents" ON storage.objects
  FOR SELECT USING (
    bucket_id = 'guardian-documents'
    AND EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid()
      AND role = 'parent'
      AND auth.uid()::text = (storage.foldername(name))[1]
    )
  );

-- Auth triggers for automatic profile creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  default_branch_id UUID;
BEGIN
  -- Get the first active branch as default, or create one if none exists
  SELECT id INTO default_branch_id FROM public.school_branches WHERE status = 'Active' LIMIT 1;

  -- If no branch exists, create a default one
  IF default_branch_id IS NULL THEN
    INSERT INTO public.school_branches (name, status, branch_id)
    VALUES ('Default School', 'Active', gen_random_uuid())
    RETURNING id INTO default_branch_id;
  END IF;

  -- Create profile for new user
  INSERT INTO public.profiles (id, email, branch_id, role, profile_completed, is_active)
  VALUES (NEW.id, NEW.email, default_branch_id, 'minimal_admin', false, true);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger on auth.users
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
